Grammar minilang;
Lexer
int = ('0'..'9')+ ;
blank = ' ' | #10 | #13 | #9;
id = ('a'..'z')+;
str = '"' (Any - '"')* '"';

Parser
Ignored blank;

prog = defs? stmts;

def = 'def' id '(' params? ')' '{' stmts '}' ;
defs = def | defs def;
params = 
	{multiple:} params ',' param |
	{single:} param ;
param = 'int' id ;

stmts = stmt | stmts stmt;

cond = 
	{eq:} [left:]assignable '==' [right:]assignable |
	{ne:} [left:]assignable '!=' [right:]assignable |
	{lte:} [left:]assignable '<=' [right:]assignable |
	{gte:} [left:]assignable '>=' [right:]assignable |
	{lt:} [left:]assignable '<' [right:]assignable |
	{gt:} [left:]assignable '>' [right:]assignable;

stmt = 
	{if:} 'if' '(' cond ')' '{' stmts '}' else |
	{while:} 'while' '(' cond ')' '{' stmts '}' |
	{print:} 'print' '(' [expr:]assignable ')' ';' |
	{print_str:} 'print' '(' str ')' ';' |
	{decl:} 'int' id ';' |
	{return:} 'return' [expr:]assignable? ';' |
	{assign:} id '=' [expr:]assignable ';' |
	{call:} call ';' ;

call =
	id '(' arguments? ')' ;

arguments = 
	{multiple:} arguments ',' [expr:]assignable |
	{single:} [expr:]assignable ;

else =
	{none:} |
	{elseif:} 'else' 'if' '(' cond ')' '{' stmts '}' else |
	{else:} 'else' '{' stmts '}';

assignable = 
	{expr:} expr |
	{call:} call ;

expr = 
	expr_2 {->};

expr_2 {->expr} = 
	{mod:} [left:]expr_2 '%' [right:]expr_3 |
	{mul:} [left:]expr_2 '*' [right:]expr_3 |
	{div:} [left:]expr_2 '/' [right:]expr_3 |
	expr_3 {->};

expr_3 {->expr} =
	{add:} [left:]expr_3 '+' [right:]expr_4 |
	{sub:} [left:]expr_3 '-' [right:]expr_4 |
	expr_4 {->};

expr_4 {->expr} =
	{neg:} '-' expr_4 |
	{par:} '(' expr ')' |
	{var:} id |
	{read:} 'read' '(' ')' |
	{int:} int;
